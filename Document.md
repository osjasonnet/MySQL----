# 概述

>本章解释了如何优化MySQL性能并提供了示例。
>优化包括配置,调优,在几个不同的层次和测量性能。
>根据你的工作角色(开发人员、DBA或两者的结合)你可能会优化SQL语句在个人的层面上,整个应用程序,一个数据库服务器,或多个网络数据库服务器。
>有时你可以主动的和计划提前表现,而其他时候你可能解决配置问题发生后或代码问题。
>优化CPU和内存使用情况还可以提高可伸缩性,允许数据库来处理更多的负载没有放缓。

##优化概述

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在数据库级数据库性能取决于几个因素,如表、查询和配置设置。这些软件构造导致CPU和I / O操作在硬件层面,这你必须最小化,使尽可能高效。工作时对数据库性能,首先需要学习软件方面的高级规则和指导方针,并使用所测量性能。当你成为一个专家,你了解更多关于内部发生了什么,并开始测量诸如CPU周期和I / O操作。

典型用户的目标是获得最佳的数据库性能的现有的软件和硬件配置。高级用户寻找机会提高MySQL软件本身,或开发自己的存储引擎和硬件设备,扩大MySQL的生态系统。

###在数据库级优化

&nbsp;&nbsp;&nbsp;&nbsp;最重要的因素做一个数据库应用程序迅速是它的基本设计:

 * 表结构正确吗?特别是,列有正确的数据类型,和每个表有适当的列类型的工作吗?例如,执行频繁更新的应用程序通常有很多表有几列,同时分析大量数据的应用程序通常有几个表有很多列。
 * 是正确的索引来提高查询效率?
 * 你是使用适当的存储引擎为每个表,并利用每个存储引擎使用的优点和特性?特别是,InnoDB等事务性存储引擎的选择或交易性等MyISAM可以非常重要的性能和可伸缩性。
 >请注意
 >在MySQL 5.5和更高版本,InnoDB的默认存储引擎的新表。在实践中,高级InnoDB性能特性意味着InnoDB表通常比简单的MyISAM表,特别是对于一个忙碌的数据库。
 * 每个表使用一个适当的行格式吗?这个选择还取决于表的存储引擎使用。特别是,压缩表使用更少的磁盘空间,所以需要更少的磁盘I / O读取和写入数据。压缩与InnoDB表可用于所有类型的工作负载,和只读MyISAM表。
 * 应用程序使用一个适当的锁定策略吗?例如,在可能的情况下,允许共享访问,数据库操作可以同时运行,在适当的时候和请求独立访问,关键操作得到的首要任务。再次,存储引擎的选择是重要的。InnoDB存储引擎处理大多数锁定问题没有你的参与,允许更好的数据库的并发性和减少实验和调优您的代码。
 * 所有内存区域用于缓存大小的正确吗?足够大,经常被访问的数据,但他们不是那么大,过载物理内存并导致分页。主内存区域配置InnoDB的缓冲池,MyISAM键缓存,MySQL查询缓存。

###优化的硬件水平

&nbsp;&nbsp;&nbsp;&nbsp;任何数据库应用程序最终达到硬件限制数据库变得越来越忙。DBA必须评估是否可以调优应用程序或重新配置服务器来避免这些瓶颈,还是需要更多的硬件资源。系统瓶颈通常来自这些来源:

 * 磁盘寻址。磁盘需要时间找到一块数据。随着现代磁盘,这通常意味着时间低于10毫秒,所以我们可以在理论上做大约100寻求第二个。这段时间慢慢改善新磁盘和很难优化为一个表。优化寻道时间的方法是将数据分发到多个磁盘。
 * 磁盘读写。当磁盘在正确的位置,我们需要读或写数据。随着现代磁盘,一个磁盘提供至少10-20MB/s的吞吐量。这是更容易比寻址优化,因为你可以从多个磁盘并行读取。
 * CPU周期。当数据在主内存,我们必须处理得到的结果。拥有大型表的内存数量相比是最常见的限制因素。但是随着小桌子,速度通常不是问题。
 * 内存带宽。当CPU需要更多的数据比CPU缓存,可以主内存带宽成为瓶颈。这对大多数系统是一种常见的瓶颈,这是需要注意的。
 
###平衡可移植性和性能

在便携式MySQL使用绩效导向的SQL扩展程序,您可以在/ \*包装MySQL-specific关键词在一份声明中!\* /注释分隔符。其他SQL服务器忽略注释的关键词。写评论的信息,参见9.6节,“注释语法”。
 
##优化SQL语句
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数据库应用程序的核心逻辑是通过SQL语句执行的,是否发行直接通过翻译或提交的幕后通过一个API。本节中的调优指南有助于加快各种MySQL的应用程序。指南涵盖读写数据的SQL操作,幕后的开销一般SQL操作,操作数据库监控等在特定的场景中使用。	

###优化 SELECT 语句

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在数据库中查询以 SELECT 语句的形式执行所有的查询操作。调优这些语句是一个首要任务,是否实现动态网页的次秒级响应时间,或耗费几小时时间生成一夜之间巨大的报告。

除了SELECT语句,查询调优技术也适用于构造,如创建表……作为CREATE TABLE...AS SELECT, INSERT INTO...SELECT, DELETE语句的WHERE子句。这些语句有额外的性能考虑,因为他们把写操作与read-oriented查询操作。

&nbsp;&nbsp;&nbsp;&nbsp;优化查询的主要因素有:

 * 列上建立索引在WHERE子句中使用,加快评估、筛选,最终检索结果。为了避免浪费磁盘空间,构造一组加速许多相关的索引查询中使用您的应用程序。
 * 在你的查询中减少表扫描的数量,特别是对于大表。
 * 保持表统计信息,因此优化器所需的信息来构造一个有效的执行计划。
 * 学习调优技术、索引技术,配置参数特定于每个表的存储引擎。MyISAM和InnoDB都套准则的建立和维持高性能查询。
 * 隔离和优化查询的任何部分,如一个函数调用,花过多的时间。记住这样一个函数会调用数百万次大查询或插入操作。
 * 避免转化的方式使得它很难理解的查询，特别是如果优化器做一些相同的自动转换。
 * 如果一个性能问题不容易解决的一个基本指导方针,调查特定查询的内部细节阅读EXPLAIN计划和调整您的索引,WHERE子句,加入条款,等等。(当你达到一定程度的专业知识,阅读EXPLAIN计划可能是你的每个查询开始。)
 * 调整MySQL使用缓存的内存区域的大小和属性。随着InnoDB的有效利用缓冲池,MyISAM键缓存,和MySQL查询缓存,重复检索查询运行得更快,因为结果在第二次一抽的时间里从内存中得到。
 * 即使对于一个快速运行的查询,使用缓存内存区域,您仍可能进一步优化,以便他们需要更少的内存缓存,使您的应用程序更具有可伸缩性。可伸缩性意味着应用程序可以处理更多的并发用户,更大的请求,所以没有经历性能大幅下降。
 * 处理死锁问题,查询的速度可能会受到其他会话访问表在同一时间。

####SELECT语句的速度

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一般来说,当你想让一个缓慢的SELECT……WHERE 查询速度,首先要检查是否可以添加一个索引。指标尤为重要对于参考不同的表的查询,使用连接和外键等特性。您可以使用EXPLAIN语句来确定哪些指标用于SELECT。请参见8.8.1与解释”“优化查询,和部分8.3.1,“MySQL如何使用索引”。

####MySQL中如何优化WHERE语句

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本节讨论的优化,我们可以提出处理WHERE语句。使用SELECT语句的例子,但同样的优化申请DELETE和UPDATE语句的WHERE语句。

&nbsp;&nbsp;&nbsp;&nbsp;非常快的查询的一些例子:
	
	SELECT COUNT(*) FROM tbl_name;

    SELECT MIN(key_part1),MAX(key_part1) FROM tbl_name;

    SELECT MAX(key_part2) FROM tbl_name
      WHERE key_part1=constant;

    SELECT ... FROM tbl_name
      ORDER BY key_part1,key_part2,... LIMIT 10;

    SELECT ... FROM tbl_name
      ORDER BY key_part1 DESC, key_part2 DESC, ... LIMIT 10;
	
	
 
 &nbsp;&nbsp;&nbsp;&nbsp;如果索引列数字, MySQL解决了利用二次指数只有条目查询：
 
     SELECT key_part1,key_part2 FROM tbl_name WHERE key_part1=val;
     
     SELECT COUNT(*) FROM tbl_name
      WHERE key_part1=val1 AND key_part2=val2;
 
     SELECT key_part2 FROM tbl_name GROUP BY key_part1;
 
&nbsp;&nbsp;&nbsp;&nbsp;以下查询使用索引数据中检索行不单独排序顺序: 

    SELECT ... FROM tbl_name
      ORDER BY key_part1,key_part2,... ;
      
    SELECT ... FROM tbl_name
      ORDER BY key_part1 DESC, key_part2 DESC, ... ;
 
&nbsp;&nbsp;&nbsp;&nbsp; 你也许会改写你的查询进行算术运算的速度，而牺牲可读性。因为MySQL是类似的自动优化，你通常可以避开这项工作，并把查询更容易理解和维护的形式。由MySQL的一些优化:

>[请注意]
因为MySQL优化器是正在进行的工作,并不是所有的MySQL的优化执行记录在这里。

* 删除不必要的括号:
    
           ((a AND b) AND c OR (((a AND b) AND (c AND d))))
        -> (a AND b AND c) OR (a AND b AND c AND d)
        
* 常数合并:

           (a<b AND b=c) AND a=5
        -> b>5 AND b=c AND a=5

* 常数条件删除(因为需要常数合并):
  
           (B>=5 AND B=5) OR (B=6 AND 5=5) OR (B=7 AND 5=6)
        -> B=5 OR B=6 
        
* 索引使用的常量表达式只计算一次。 
* 对于MyISAM和MEMARY表，在一个单个表上的没有一个WHERE的COUNT(*)直接从表中检索信息。当仅使用一个表时，对NOT NULL表达式也这样做。
* 无效常数表达式的早期检测。MySQL快速检测某些SELECT语句是不可能的并且不返回行。
* 如果不使用GROUP BY或分组函数(COUNT()、MIN()……)，HAVING与WHERE合并。
* 对于每个表联接，一个简单的WHERE构造得到一个快速的WHERE评价表，并尽快跳过行。
* 所有常数的表在查询中的任何其它表之前，先读。常数表如下：
  * 一个空表或一列的表格。
  * 用于与上一个PRIMARY KEY或UNIQUE索引，所有的索引部分进行比较，常量表达式和被定义为NOT NULL的WHERE子句中的表。

&nbsp;&nbsp;&nbsp;&nbsp;下列的所有的表用作常数表：

    SELECT * FROM t WHERE primary_key=1;
    
    SELECT * FROM t1,t2
      WHERE t1.primary_key=1 AND t2.primary_key=t1.id;
 
  * 尝试所有可能性便可以找到表联接的最好联接组合。如果所有在ORDER BY和GROUP BY的列来自同一个表，那么当联接时，该表首先被选中。
  * 如果有一个ORDER BY子句和不同的GROUP BY子句，或如果ORDER BY或GROUP BY包含联接队列中的第一个表之外的其它表的列，则创建一个临时表。
 * 如果您使用的SQL_SMALL_RESULT选项，MySQL使用内存中的临时表。
 * 每个表索引进行查询，而最好的索引被使用，除非优化器认为它是更有效地使用表扫描。有一段时间，扫描是基于最佳指标是否跨越了表的30％以上使用，但一个固定的百分比不再决定使用索引或扫描之间的选择。现在，优化程序较为复杂，在其他因素，如表的大小，行数和I / O块大小基于其估计。
 * MySQL查询结果有时会产生使用的数据索引,没有咨询表数据。如果所有列数字索引的使用,只用于解析查询索引数据。
 * 在每一行输出，那些确实HAVING子句不匹配被跳过。
 
###范围优化

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;范围访问方法使用一个索引来检索所包含一个或多个索引值的时间间隔内表行的子集。它可以用于单部分或多部分的索引。以下各节给出的区间是如何从WHERE子句中提取的详细说明。
 
####单元素索引的范围访问方法
&nbsp;&nbsp;&nbsp;&nbsp;对于单元素索引，可以用WHERE子句中的相应条件很方便地表示索引值区间，因此我们称为范围条件而不是“区间”。 

&nbsp;&nbsp;&nbsp;&nbsp;单元素索引范围条件的定义如下：
 
 * 对于BTREE和HASH索引，当使用=、<=>、IN、IS NULL或者IS NOT NULL操作符时，关键元素与常量值的比较关系对应一个范围条件。
 *  对于BTREE索引，当使用>、<、>=、<=、BETWEEN、!=或者<>，或者LIKE 'pattern'(其中 'pattern'不以通配符开始)操作符时，关键元素与常量值的比较关系对应一个范围条件。
 
 
 
 